/****************************************************************************/
// Copyright (c) 2016 Renesas Electronics Corporation. All rights reserved.
//
//
// FILE          : GLES_005.cpp
// DESCRIPTION   : Test for GL_EXT_shader_pixel_local_storage
// CREATED       : -
// MODIFIED      : 2016.05.18
// AUTHOR        : Renesas Electronics Corporation
// TARGET DEVICE : Common
// TARGET OS     : Common
// HISTORY       :
//                 2015.05.18
//                 - Modified for the integration test
/****************************************************************************/

#include "Headers/GLES_005.h"
#include "Headers/CreateBMP.h"
#include "ShaderCommon/GLObject/all.h"

/****************************************************************************
* Static Field
****************************************************************************/
#ifdef SUPPORT_OGLES31
#ifdef D_RUNTIME_COMPILE
const char* TestCase_EXT_shader_pixel_local_storage::kVertexSource =
"#version 310 es\n"
"layout(location=0) in highp vec4 inVertex;\n"
"void main()\n"
"{\n"
"	gl_Position = inVertex;\n"
"}\n";

const char* TestCase_EXT_shader_pixel_local_storage::kFragmentHeader =
"#version 310 es\n"
"#extension GL_EXT_shader_pixel_local_storage : enable\n";

const char* TestCase_EXT_shader_pixel_local_storage::kFragmentWriteBodyRGBA8 =
"#ifdef USE_IN_OUT\n"
"__pixel_local_outEXT FragDataLocal {\n"
"    layout(rgba8) highp vec4 color;\n"
"} gbuf;\n"
"#else\n"
"__pixel_localEXT FragDataLocal {\n"
"    layout(rgba8) highp vec4 color;\n"
"} gbuf;\n"
"#endif\n"
"\n"
"void main() \n"
"{ \n"
"    gbuf.color = vec4(1.0, 1.0 , 0, 1.0);\n"
"}\n";


const char* TestCase_EXT_shader_pixel_local_storage::kFragmentReadBodyRGBA8 =
"layout(binding=0) uniform atomic_uint counter;\n"
"\n"
"out highp vec4 outColor;\n"
"\n"
"#ifdef USE_IN_OUT\n"
"__pixel_local_inEXT FragDataLocal {\n"
"    layout(rgba8) highp vec4 color;\n"
"} gbuf;\n"
"#else\n"
"__pixel_localEXT FragDataLocal {\n"
"    layout(rgba8) highp vec4 color;\n"
"} gbuf;\n"
"#endif\n"
"void main() \n"
"{ \n"
"	outColor = gbuf.color;\n"
"   if(gbuf.color != vec4(1.0, 1.0 , 0, 1.0)) {\n"
"       atomicCounterIncrement(counter);\n"
"   }\n"
"}\n";

const char* TestCase_EXT_shader_pixel_local_storage::kFragmentWriteBodyRGBA8I =
"#ifdef USE_IN_OUT\n"
"__pixel_local_outEXT FragDataLocal {\n"
"    layout(rgba8i) mediump ivec4 color;\n"
"} gbuf;\n"
"#else\n"
"__pixel_localEXT FragDataLocal {\n"
"    layout(rgba8i) mediump ivec4 color;\n"
"} gbuf;\n"
"#endif\n"
"\n"
"void main() \n"
"{ \n"
"    gbuf.color = ivec4(1.0, 1.0 , 0, 1.0);\n"
"}\n";


const char* TestCase_EXT_shader_pixel_local_storage::kFragmentReadBodyRGBA8I =
"layout(binding=0) uniform atomic_uint counter;\n"
"\n"
"out highp vec4 outColor;\n"
"\n"
"#ifdef USE_IN_OUT\n"
"__pixel_local_inEXT FragDataLocal {\n"
"    layout(rgba8i) mediump ivec4 color;\n"
"} gbuf;\n"
"#else\n"
"__pixel_localEXT FragDataLocal {\n"
"    layout(rgba8i) mediump ivec4 color;\n"
"} gbuf;\n"
"#endif\n"
"void main() \n"
"{ \n"
"	outColor = vec4(gbuf.color);\n"
"   if(gbuf.color != ivec4(1, 1 , 0, 1)) {\n"
"       atomicCounterIncrement(counter);\n"
"   }\n"
"}\n";

const char* TestCase_EXT_shader_pixel_local_storage::kFragmentWriteBodyRGBA8UI =
"#ifdef USE_IN_OUT\n"
"__pixel_local_outEXT FragDataLocal {\n"
"    layout(rgba8ui) uvec4 color;\n"
"} gbuf;\n"
"#else\n"
"__pixel_localEXT FragDataLocal {\n"
"    layout(rgba8ui) uvec4 color;\n"
"} gbuf;\n"
"#endif\n"
"\n"
"void main() \n"
"{ \n"
"    gbuf.color = uvec4(1, 1, 0, 1);\n"
"}\n";


const char* TestCase_EXT_shader_pixel_local_storage::kFragmentReadBodyRGBA8UI =
"layout(binding=0) uniform atomic_uint counter;\n"
"\n"
"out highp vec4 outColor;\n"
"\n"
"#ifdef USE_IN_OUT\n"
"__pixel_local_inEXT FragDataLocal {\n"
"    layout(rgba8ui) mediump uvec4 color;\n"
"} gbuf;\n"
"#else\n"
"__pixel_localEXT FragDataLocal {\n"
"    layout(rgba8ui) mediump uvec4 color;\n"
"} gbuf;\n"
"#endif\n"
"void main() \n"
"{ \n"
"	outColor = vec4(gbuf.color);\n"
"   if(gbuf.color != uvec4(1, 1, 0, 1)) {\n"
"       atomicCounterIncrement(counter);\n"
"   }\n"
"}\n";
#else
const char* TestCase_EXT_shader_pixel_local_storage::kVertexSource = "Resources/GLES_005/GLES_005_VertShader"BINARY_NAME_EXT;
const char* TestCase_EXT_shader_pixel_local_storage::kFragmentWriteBodyRGBA8 ="Resources/GLES_005/GLES_005_FragmentWriteBodyRGBA8"BINARY_NAME_EXT;
const char* TestCase_EXT_shader_pixel_local_storage::kFragmentWriteBodyRGBA8_2 = "Resources/GLES_005/GLES_005_FragmentReadBodyRGBA8_2"BINARY_NAME_EXT;
const char* TestCase_EXT_shader_pixel_local_storage::kFragmentReadBodyRGBA8 ="Resources/GLES_005/GLES_005_FragmentReadBodyRGBA8"BINARY_NAME_EXT;
const char* TestCase_EXT_shader_pixel_local_storage::kFragmentReadBodyRGBA8_2 ="Resources/GLES_005/GLES_005_FragmentReadBodyRGBA8_2"BINARY_NAME_EXT;
const char* TestCase_EXT_shader_pixel_local_storage::kFragmentWriteBodyRGBA8I ="Resources/GLES_005/GLES_005_FragmentWriteBodyRGBA8I"BINARY_NAME_EXT;
const char* TestCase_EXT_shader_pixel_local_storage::kFragmentWriteBodyRGBA8I_2 ="Resources/GLES_005/GLES_005_FragmentWriteBodyRGBA8I_2"BINARY_NAME_EXT;
const char* TestCase_EXT_shader_pixel_local_storage::kFragmentReadBodyRGBA8I ="Resources/GLES_005/GLES_005_FragmentReadBodyRGBA8I"BINARY_NAME_EXT;
const char* TestCase_EXT_shader_pixel_local_storage::kFragmentReadBodyRGBA8I_2 = "Resources/GLES_005/GLES_005_FragmentReadBodyRGBA8I_2"BINARY_NAME_EXT;
const char* TestCase_EXT_shader_pixel_local_storage::kFragmentWriteBodyRGBA8UI = "Resources/GLES_005/GLES_005_FragmentWriteBodyRGBA8UI"BINARY_NAME_EXT;
const char* TestCase_EXT_shader_pixel_local_storage::kFragmentWriteBodyRGBA8UI_2 = "Resources/GLES_005/GLES_005_FragmentWriteBodyRGBA8UI_2"BINARY_NAME_EXT;
const char* TestCase_EXT_shader_pixel_local_storage::kFragmentReadBodyRGBA8UI = "Resources/GLES_005/GLES_005_FragmentReadBodyRGBA8UI"BINARY_NAME_EXT;
const char* TestCase_EXT_shader_pixel_local_storage::kFragmentReadBodyRGBA8UI_2 = "Resources/GLES_005/GLES_005_FragmentReadBodyRGBA8UI_2"BINARY_NAME_EXT;
#endif
#endif // SUPPORT_OGLES31

#define D_TEST_KEY			"02_IT"
#define D_TEST_PACKAGE 		"KhronosExtentions"
#define D_TEST_NAME    		"GL_EXT_shader_pixel_local_storage"

/****************************************************************************
* Class Constructor/Destructor
****************************************************************************/

TestCase_EXT_shader_pixel_local_storage::TestCase_EXT_shader_pixel_local_storage(pvr::Shell* context)
: TestCase_Extension(context, "GL_EXT_shader_pixel_local_storage")
{
	m_AtomicCounter = NULL;
	m_ReadProgram = NULL;
	m_WriteProgram = NULL;
}

/****************************************************************************
* TextCase_Unit Interface
****************************************************************************/

bool TestCase_EXT_shader_pixel_local_storage::Setup()
{
	if (!TestCase_Extension::Setup())
		return false;
	glGetError();
	
	for (int i = 0; i < 15 * 15; i++) {
		data[i].r = 0xFF * (i % 15) / 15;
		data[i].g = 0xFF * (i / 15) / 15;
		data[i].b = 0xFF * i / (15 * 15);
		data[i].a = 0xFF;
	}

	return (glGetError() == GL_NO_ERROR);
}

void TestCase_EXT_shader_pixel_local_storage::TearDown()
{
}

void TestCase_EXT_shader_pixel_local_storage::Run()
{
	TestCase_Extension::Run();
	bool ret = Run_ImplementionDefined();
	if (ret){
//		Dump("Abnormal case >>");
//		RunAbnormalTestCase(1, "GL_EXT_shader_pixel_local_storage_A", "001");
//		RunAbnormalTestCase(2, "GL_EXT_shader_pixel_local_storage_A", "002");
//		RunAbnormalTestCase(3, "GL_EXT_shader_pixel_local_storage_A", "003");

		Dump("Normal case >>");
		RunNormalTestCaseRGBA8I(1, "GL_EXT_shader_pixel_local_storage_N", "003");
//		RunNormalTestCaseRGBA8I(2, "GL_EXT_shader_pixel_local_storage_N", "004");
//		RunNormalTestCaseRGBA8UI(1, "GL_EXT_shader_pixel_local_storage_N", "005");
//		RunNormalTestCaseRGBA8UI(2, "GL_EXT_shader_pixel_local_storage_N", "006");
//		RunNormalTestCaseRGBA8(1, "GL_EXT_shader_pixel_local_storage_N", "001");
//		RunNormalTestCaseRGBA8(2, "GL_EXT_shader_pixel_local_storage_N", "002");
	}
}

void TestCase_EXT_shader_pixel_local_storage::Render(CPVRTPrint3D& print)
{
}

/****************************************************************************
* TextCase Interface
****************************************************************************/

/****************************************************************************
* Function   : Run_ImplementionDefined
* Description: Check implemented value 
* MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT
* MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT
****************************************************************************/
bool TestCase_EXT_shader_pixel_local_storage::Run_ImplementionDefined()
{
	Dump("== Implemention Defined ==");

	{
		Test test = Start("MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT");
		GLint64 value;
		glGetInteger64v(
			GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT,
			&value);
		if (glGetError() == GL_INVALID_ENUM) {
			test.Skip();
			Dump("glGetError returns GL_INVALID_ENUM");
			return false;
		}
		if (value >= 16) {
			test.Pass();
			DUMP_FORMAT(this, "MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT value is: %lld", value);
		}
	}
	{
		Test test = Start("MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT");
		GLint64 value;
		glGetInteger64v(
			GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT,
			&value);
		if (glGetError() == GL_INVALID_ENUM) {
			test.Skip();
			Dump("glGetError returns GL_INVALID_ENUM");
			return false;
		}
		if (value >= 16) {
			test.Pass();
			DUMP_FORMAT(this, "MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT value is: %lld", value);
		}
	}

	return (glGetError() == GL_NO_ERROR);
}

/****************************************************************************
* Function   : RunNormalTestCaseRGBA8
* Description: Run normal test case with local storage format: GL_RGBA8
*	1. Used __pixel_localEXT  in GLSL program
*	2. Used __pixel_local_outEXT, __pixel_local_inEXT in GLSL program
****************************************************************************/
void TestCase_EXT_shader_pixel_local_storage::RunNormalTestCaseRGBA8(GLint id, const char* test_name, const char* test_id)
{
	Test test = Start(D_TEST_KEY, D_TEST_PACKAGE, test_name, test_id, "Normal");
	
	GLint status=1;
	m_AtomicCounter = new BufferObject();
	GLuint init_val = 0;
	glBindBuffer(GL_ATOMIC_COUNTER_BUFFER, m_AtomicCounter->GetObject());
	glBufferData(GL_ATOMIC_COUNTER_BUFFER, sizeof(GLuint), &init_val, GL_DYNAMIC_READ);
	glBindBuffer(GL_ATOMIC_COUNTER_BUFFER, 0);
	
	glEnable(GL_SHADER_PIXEL_LOCAL_STORAGE_EXT);
	GLfloat vertex[] = {
		-1.0, -1.0, 0.0, 1.0,
		1.0, -1.0, 0.0, 1.0,
		1.0, 1.0, 0.0, 1.0,
		-1.0, 1.0, 0.0, 1.0,
	};

	//SetupShader
#ifdef D_RUNTIME_COMPILE
	Shader::Source v_source(kVertexSource);
	Shader::Source w_source;
	
	w_source.SetHeader(kFragmentHeader);
	w_source.SetBody(kFragmentWriteBodyRGBA8);

	Shader::Source r_source;
	r_source.SetHeader(kFragmentHeader);
	r_source.SetBody(kFragmentReadBodyRGBA8);

	//Normal test case 002: __pixel_local_inEXT, __pixel_local_outEXT
	if (id == 2){
		//Test case normal ID_002
		w_source.AddDefine("USE_IN_OUT", 1);
		r_source.AddDefine("USE_IN_OUT", 1);
	}

	m_WriteProgram = RenderProgram::Create(v_source, w_source, this);
	if (!m_WriteProgram) {
		test.Fail();
		Dump("Compile Failed");
		return;
	}

	m_ReadProgram = RenderProgram::Create(v_source, r_source, this);
	if (!m_ReadProgram) {
		test.Fail();
		Dump("Compile Failed");
		return;
	}
#else
	//Normal test case 002: __pixel_local_inEXT, __pixel_local_outEXT
	if (id == 2){
		//Test case normal ID_002
		m_WriteProgram = RenderProgram::CreateFromBin(kVertexSource, kFragmentWriteBodyRGBA8_2, this);
		m_ReadProgram = RenderProgram::CreateFromBin(kVertexSource, kFragmentReadBodyRGBA8_2, this);
	}
	else {
		m_WriteProgram = RenderProgram::CreateFromBin(kVertexSource, kFragmentWriteBodyRGBA8, this);
		m_ReadProgram = RenderProgram::CreateFromBin(kVertexSource, kFragmentReadBodyRGBA8, this);
	}
	if (!m_ReadProgram || !m_WriteProgram) {
		test.Fail();
		Dump("Compile Failed");
		return;
	}
#endif
	glBindBufferBase(GL_ATOMIC_COUNTER_BUFFER, 0, m_AtomicCounter->GetObject());
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, sizeof(GL_FLOAT)* 4, vertex);

	glUseProgram(m_WriteProgram->GetObject());
	glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
	glUseProgram(0);

	glUseProgram(m_ReadProgram->GetObject());
	glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
	glUseProgram(0);
	
	glMemoryBarrier(GL_ALL_BARRIER_BITS);
	glBindBufferBase(GL_ATOMIC_COUNTER_BUFFER, 0, 0);
	
	GLuint data;
	glBindBuffer(GL_ATOMIC_COUNTER_BUFFER, m_AtomicCounter->GetObject());
	{
		GLuint* buffer = static_cast<GLuint*>(glMapBufferRange(
			GL_ATOMIC_COUNTER_BUFFER,
			0,
			sizeof(GLuint),
			GL_MAP_READ_BIT));

		GLError err = glGetError();
		if (err != GL_NO_ERROR) {
			Dump(err.ToString());
		}

		if (!buffer){
			Dump("glMapBufferRange Failed");
			test.Skip("Error Occured");
		}
		else{
			data = *buffer;
		}
		glUnmapBuffer(GL_ATOMIC_COUNTER_BUFFER);
	}
	glBindBuffer(GL_ATOMIC_COUNTER_BUFFER, 0);

	if (data == 0) {
		if(id == 1){		
			CreateBMPFromSurface("GLES_005_N_001.bmp", 0, 0, GetWidth(), GetHeight() );
			if (CheckCRCPixels( GLES_005_N_001, "GLES_005_N_001.bmp", GetWidth(), GetHeight())  == true){
				printf("Check pixel color : OK \n");
				test.Pass();
			} else {
				printf("Check pixel color : NG \n");
				test.Fail();
			}
		}else if(id == 2){
			CreateBMPFromSurface("GLES_005_N_002.bmp", 0, 0, GetWidth(), GetHeight() );
			if (CheckCRCPixels( GLES_005_N_002, "GLES_005_N_002.bmp", GetWidth(), GetHeight())  == true){
				printf("Check pixel color : OK \n");
				test.Pass();
			} else {
				printf("Check pixel color : NG \n");
				test.Fail();
			}
		}
	}
	else{
		test.Fail();
		DUMP_FORMAT(this, "%u pixels illigal", data)
	}
	
	glDisable(GL_SHADER_PIXEL_LOCAL_STORAGE_EXT);

	SAFE_DELETE(m_ReadProgram);
	SAFE_DELETE(m_WriteProgram);
	SAFE_DELETE(m_AtomicCounter);
}

/****************************************************************************
* Function   : RunNormalTestCaseRGBA8I
* Description: Run normal test case with local storage format: GL_RGBA8I
*	1. Used __pixel_localEXT  in GLSL program
*	2. Used __pixel_local_outEXT, __pixel_local_inEXT in GLSL program
****************************************************************************/
void TestCase_EXT_shader_pixel_local_storage::RunNormalTestCaseRGBA8I(GLint id, const char* test_name, const char* test_id)
{
	Test test = Start(D_TEST_KEY, D_TEST_PACKAGE, test_name, test_id, "Normal");
	
	GLint status=1;
	m_AtomicCounter = new BufferObject();
	GLuint init_val = 0;
	glBindBuffer(GL_ATOMIC_COUNTER_BUFFER, m_AtomicCounter->GetObject());
	glBufferData(GL_ATOMIC_COUNTER_BUFFER, sizeof(GLuint), &init_val, GL_DYNAMIC_READ);
	glBindBuffer(GL_ATOMIC_COUNTER_BUFFER, 0);
	
	glEnable(GL_SHADER_PIXEL_LOCAL_STORAGE_EXT);
	GLfloat vertex[] = {
		-1.0, -1.0, 0.0, 1.0,
		1.0, -1.0, 0.0, 1.0,
		1.0, 1.0, 0.0, 1.0,
		-1.0, 1.0, 0.0, 1.0,
	};

#ifdef D_RUNTIME_COMPILE
	//SetupShader
	Shader::Source v_source(kVertexSource);
	Shader::Source w_source;
	w_source.SetHeader(kFragmentHeader);
	w_source.SetBody(kFragmentWriteBodyRGBA8I);

	Shader::Source r_source;
	r_source.SetHeader(kFragmentHeader);
	r_source.SetBody(kFragmentReadBodyRGBA8I);

	//Normal test case 002: __pixel_local_inEXT, __pixel_local_outEXT
	if (id == 2){
		//Test case normal ID_002
		w_source.AddDefine("USE_IN_OUT", 1);
		r_source.AddDefine("USE_IN_OUT", 1);
	}

	m_WriteProgram = RenderProgram::Create(v_source, w_source, this);
	if (!m_WriteProgram) {
		test.Fail();
		Dump("Compile Failed");
		return;
	}

	m_ReadProgram = RenderProgram::Create(v_source, r_source, this);
	if (!m_ReadProgram) {
		test.Fail();
		Dump("Compile Failed");
		return;
	}
#else
	//Normal test case 002: __pixel_local_inEXT, __pixel_local_outEXT
	if (id == 2){
		//Test case normal ID_002
		m_WriteProgram = RenderProgram::CreateFromBin(kVertexSource, kFragmentWriteBodyRGBA8I_2, this);
		m_ReadProgram = RenderProgram::CreateFromBin(kVertexSource, kFragmentReadBodyRGBA8I_2, this);
	}
	else {
		m_WriteProgram = RenderProgram::CreateFromBin(kVertexSource, kFragmentWriteBodyRGBA8I, this);
		m_ReadProgram = RenderProgram::CreateFromBin(kVertexSource, kFragmentReadBodyRGBA8I, this);
	}
	if (!m_ReadProgram || !m_WriteProgram) {
		test.Fail();
		Dump("Compile Failed");
		return;
	}
#endif
	glBindBufferBase(GL_ATOMIC_COUNTER_BUFFER, 0, m_AtomicCounter->GetObject());
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, sizeof(GL_FLOAT)* 4, vertex);

	glUseProgram(m_WriteProgram->GetObject());
	glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
	glUseProgram(0);

	glUseProgram(m_ReadProgram->GetObject());
	glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
	glUseProgram(0);


	glMemoryBarrier(GL_ALL_BARRIER_BITS);
	glBindBufferBase(GL_ATOMIC_COUNTER_BUFFER, 0, 0);

	GLuint data;
	glBindBuffer(GL_ATOMIC_COUNTER_BUFFER, m_AtomicCounter->GetObject());
	{
		GLuint* buffer = static_cast<GLuint*>(glMapBufferRange(
			GL_ATOMIC_COUNTER_BUFFER,
			0,
			sizeof(GLuint),
			GL_MAP_READ_BIT));

		GLError err = glGetError();
		if (err != GL_NO_ERROR) {
			Dump(err.ToString());
		}

		if (!buffer){
			Dump("glMapBufferRange Failed");
			test.Skip("Error Occured");
		}
		else{
			data = *buffer;
		}
		glUnmapBuffer(GL_ATOMIC_COUNTER_BUFFER);
	}
	glBindBuffer(GL_ATOMIC_COUNTER_BUFFER, 0);

	if (data == 0) {
		if(id == 1){		
			CreateBMPFromSurface("GLES_005_N_003.bmp", 0, 0, GetWidth(), GetHeight() );
			if (CheckCRCPixels( GLES_005_N_003, "GLES_005_N_003.bmp", GetWidth(), GetHeight())  == true){
				printf("Check pixel color : OK \n");
				test.Pass();
			} else {
				printf("Check pixel color : NG \n");
				test.Fail();
			}
		}else if(id == 2){
			CreateBMPFromSurface("GLES_005_N_004.bmp", 0, 0, GetWidth(), GetHeight() );
			if (CheckCRCPixels( GLES_005_N_004, "GLES_005_N_004.bmp", GetWidth(), GetHeight())  == true){
				printf("Check pixel color : OK \n");
				test.Pass();
			} else {
				printf("Check pixel color : NG \n");
				test.Fail();
			}
		}
	}
	else{
		test.Fail();
		DUMP_FORMAT(this, "%u pixels illigal", data)
	}
	glDisable(GL_SHADER_PIXEL_LOCAL_STORAGE_EXT);
	//Clean up
	SAFE_DELETE(m_WriteProgram);
	SAFE_DELETE(m_ReadProgram);
	SAFE_DELETE(m_AtomicCounter);
}

/****************************************************************************
* Function   : RunNormalTestCaseRGBA8UI
* Description: Run normal test case with local storage format: GL_RGBA8UI
*	1. Used __pixel_localEXT  in GLSL program
*	2. Used __pixel_local_outEXT, __pixel_local_inEXT in GLSL program
****************************************************************************/
void TestCase_EXT_shader_pixel_local_storage::RunNormalTestCaseRGBA8UI(GLint id, const char* test_name, const char* test_id)
{
	Test test = Start(D_TEST_KEY, D_TEST_PACKAGE, test_name, test_id, "Normal");
	
	GLint status=1;	
	m_AtomicCounter = new BufferObject();
	GLuint init_val = 0;
	glBindBuffer(GL_ATOMIC_COUNTER_BUFFER, m_AtomicCounter->GetObject());
	glBufferData(GL_ATOMIC_COUNTER_BUFFER, sizeof(GLuint), &init_val, GL_DYNAMIC_READ);
	glBindBuffer(GL_ATOMIC_COUNTER_BUFFER, 0);
	
	glEnable(GL_SHADER_PIXEL_LOCAL_STORAGE_EXT);
	GLfloat vertex[] = {
		-1.0, -1.0, 0.0, 1.0,
		1.0, -1.0, 0.0, 1.0,
		1.0, 1.0, 0.0, 1.0,
		-1.0, 1.0, 0.0, 1.0,
	};
#ifdef D_RUNTIME_COMPILE
	//SetupShader
	Shader::Source v_source(kVertexSource);
	Shader::Source w_source;
	w_source.SetHeader(kFragmentHeader);
	w_source.SetBody(kFragmentWriteBodyRGBA8UI);

	Shader::Source r_source;
	r_source.SetHeader(kFragmentHeader);
	r_source.SetBody(kFragmentReadBodyRGBA8UI);

	//Normal test case 002: __pixel_local_inEXT, __pixel_local_outEXT
	if (id == 2){
		//Test case normal ID_002
		w_source.AddDefine("USE_IN_OUT", 1);
		r_source.AddDefine("USE_IN_OUT", 1);
	}

	m_WriteProgram = RenderProgram::Create(v_source, w_source, this);
	if (!m_WriteProgram) {
		test.Fail();
		Dump("Compile Failed");
		return;
	}

	m_ReadProgram = RenderProgram::Create(v_source, r_source, this);
	if (!m_ReadProgram) {
		test.Fail();
		Dump("Compile Failed");
		return;
	}
#else
	//Normal test case 002: __pixel_local_inEXT, __pixel_local_outEXT
	if (id == 2){
		//Test case normal ID_002
		m_WriteProgram = RenderProgram::CreateFromBin(kVertexSource, kFragmentWriteBodyRGBA8UI_2, this);
		m_ReadProgram = RenderProgram::CreateFromBin(kVertexSource, kFragmentReadBodyRGBA8UI_2, this);
	}
	else {
		m_WriteProgram = RenderProgram::CreateFromBin(kVertexSource, kFragmentWriteBodyRGBA8UI, this);
		m_ReadProgram = RenderProgram::CreateFromBin(kVertexSource, kFragmentReadBodyRGBA8UI, this);
	}
	if (!m_ReadProgram || !m_WriteProgram) {
		test.Fail();
		Dump("Compile Failed");
		return;
	}
#endif
	glBindBufferBase(GL_ATOMIC_COUNTER_BUFFER, 0, m_AtomicCounter->GetObject());
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, sizeof(GL_FLOAT)* 4, vertex);

	glUseProgram(m_WriteProgram->GetObject());
	glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
	glUseProgram(0);

	glUseProgram(m_ReadProgram->GetObject());
	glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
	glUseProgram(0);


	glMemoryBarrier(GL_ALL_BARRIER_BITS);
	glBindBufferBase(GL_ATOMIC_COUNTER_BUFFER, 0, 0);

	GLuint data;
	glBindBuffer(GL_ATOMIC_COUNTER_BUFFER, m_AtomicCounter->GetObject());
	{
		GLuint* buffer = static_cast<GLuint*>(glMapBufferRange(
			GL_ATOMIC_COUNTER_BUFFER,
			0,
			sizeof(GLuint),
			GL_MAP_READ_BIT));

		GLError err = glGetError();
		if (err != GL_NO_ERROR) {
			Dump(err.ToString());
		}

		if (!buffer){
			Dump("glMapBufferRange Failed");
			test.Skip("Error Occured");
		}
		else{
			data = *buffer;
		}
		glUnmapBuffer(GL_ATOMIC_COUNTER_BUFFER);
	}
	glBindBuffer(GL_ATOMIC_COUNTER_BUFFER, 0);

	if(data == 0){
		if(id == 1){		
			CreateBMPFromSurface("GLES_005_N_005.bmp", 0, 0, GetWidth(), GetHeight() );
			if (CheckCRCPixels( GLES_005_N_005, "GLES_005_N_005.bmp", GetWidth(), GetHeight())  == true){
				printf("Check pixel color : OK \n");
				test.Pass();
			} else {
				printf("Check pixel color : NG \n");
				test.Fail();
			}
		} else if(id == 2){
			CreateBMPFromSurface("GLES_005_N_006.bmp", 0, 0, GetWidth(), GetHeight() );
			if (CheckCRCPixels( GLES_005_N_006, "GLES_005_N_006.bmp", GetWidth(), GetHeight())  == true){
				printf("Check pixel color : OK \n");
				test.Pass();
			} else {
				printf("Check pixel color : NG \n");
				test.Fail();
			}
		}
	}
	else{
		test.Fail();
		DUMP_FORMAT(this, "%u pixels illigal", data)
	}
	glDisable(GL_SHADER_PIXEL_LOCAL_STORAGE_EXT);
	//Clean up
	SAFE_DELETE(m_WriteProgram);
	SAFE_DELETE(m_ReadProgram);
	SAFE_DELETE(m_AtomicCounter);
}

/****************************************************************************
* Function   : RunAbnormalTestCase
* Description: Run abnormal test case with local storage format: GL_RGBA8
*	1. Not call glEnable()
*	2. Access data local storage after call glDisable()
*	3. Attempting to enable pixel local storage while the current draw
*   framebuffer is a user - defined framebuffer and has an image attached to 
*   any color attachment other than color attachment zero
****************************************************************************/
void TestCase_EXT_shader_pixel_local_storage::RunAbnormalTestCase(GLint id, const char* test_name, const char* test_id)
{
	Test test = Start(D_TEST_KEY, D_TEST_PACKAGE, test_name, test_id, "Abnormal");

	m_AtomicCounter = new BufferObject();
	GLuint init_val = 0;
	glBindBuffer(GL_ATOMIC_COUNTER_BUFFER, m_AtomicCounter->GetObject());
	glBufferData(GL_ATOMIC_COUNTER_BUFFER, sizeof(GLuint), &init_val, GL_DYNAMIC_READ);
	glBindBuffer(GL_ATOMIC_COUNTER_BUFFER, 0);
	
	GLfloat vertex[] = {
		0.0, 0.0, 0.0, 1.0,
		1.0, 0.0, 0.0, 1.0,
		1.0, 1.0, 0.0, 1.0,
		0.0, 1.0, 0.0, 1.0,
	};
#ifdef D_RUNTIME_COMPILE
	//SetupShader
	Shader::Source v_source(kVertexSource);
	Shader::Source w_source;
	w_source.SetHeader(kFragmentHeader);
	w_source.SetBody(kFragmentWriteBodyRGBA8);

	Shader::Source r_source;
	r_source.SetHeader(kFragmentHeader);
	r_source.SetBody(kFragmentReadBodyRGBA8);

	m_WriteProgram = RenderProgram::Create(v_source, w_source, this);
	if (!m_WriteProgram) {
		test.Fail();
		Dump("Compile Failed");
		return;
	}

	m_ReadProgram = RenderProgram::Create(v_source, r_source, this);
	if (!m_ReadProgram) {
		test.Fail();
		Dump("Compile Failed");
		return;
	}
#else
	m_WriteProgram = RenderProgram::CreateFromBin(kVertexSource, kFragmentWriteBodyRGBA8, this);
	m_ReadProgram = RenderProgram::CreateFromBin(kVertexSource, kFragmentReadBodyRGBA8, this);
	if (!m_ReadProgram || !m_WriteProgram) {
		test.Fail();
		Dump("Compile Failed");
		return;
	}
#endif
	GLError err = GL_NO_ERROR;

	switch (id)
	{
	case 1:
		//Not call function: glEnable(GL_SHADER_PIXEL_LOCAL_STORAGE_EXT)
		glUseProgram(m_WriteProgram->GetObject());
		glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
		glUseProgram(0);

		glUseProgram(m_ReadProgram->GetObject());
		glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
		glUseProgram(0);

		err = glGetError();
		if (err != GL_NO_ERROR){
			test.Pass();
			Dump(err.ToString());
			return;
		}
		else{
			test.Fail();
		}

		glDisable(GL_SHADER_PIXEL_LOCAL_STORAGE_EXT);
		break;
	case 2:
		//Cannot access local storage data after call function: glDisable(GL_SHADER_PIXEL_LOCAL_STORAGE_EXT)
		glEnable(GL_SHADER_PIXEL_LOCAL_STORAGE_EXT);
		glDisable(GL_SHADER_PIXEL_LOCAL_STORAGE_EXT);
		
		glUseProgram(m_WriteProgram->GetObject());
		glDrawArrays(GL_TRIANGLE_FAN, 0, 4);

		glUseProgram(m_ReadProgram->GetObject());
		glDrawArrays(GL_TRIANGLE_FAN, 0, 4);

		err = glGetError();
		if (err != GL_NO_ERROR){
			test.Pass();
			Dump(err.ToString());
			return;
		}
		else{
			test.Fail();
		}
		break;
	case 3:
		glEnable(GL_SHADER_PIXEL_LOCAL_STORAGE_EXT);
		glGenTextures(1, &m_TextureBuffer);
		glBindTexture(GL_TEXTURE_2D, m_TextureBuffer);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 15, 15, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);

		//Create Framebuffer and attached Texture
		glGenFramebuffers(1, &m_Framebuffer);
		glBindFramebuffer(GL_FRAMEBUFFER, m_Framebuffer);
		glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, m_TextureBuffer, 0);
		glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, m_TextureBuffer, 0);
		glBindFramebuffer(GL_FRAMEBUFFER, 0);

		glBindFramebuffer(GL_FRAMEBUFFER, m_Framebuffer);

		GLenum drawBuffers2[] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 };
		glDrawBuffers(2, drawBuffers2);

		err = glGetError();
		if (err != GL_NO_ERROR){
			test.Pass();
			Dump(err.ToString());
		}
		else{
			test.Fail();
		}
		
		glBindTexture(GL_TEXTURE_2D, 0);
		glBindFramebuffer(GL_FRAMEBUFFER, 0);

		glDisable(GL_SHADER_PIXEL_LOCAL_STORAGE_EXT);
		glDeleteTextures(1, &m_TextureBuffer);
		break;
	}
	
	//clean up
	SAFE_DELETE(m_ReadProgram);
	SAFE_DELETE(m_WriteProgram);
	SAFE_DELETE(m_AtomicCounter);
}
